from automation.finance import *

class Base:

    def __init__(
        self,
        bank: str
    ):
        """
        Base class for all Bank classes
        :param bank: bank name
        """

        self.bank = bank
        self.ignored_exceptions = (
            ValueError,
            IndexError,
            NoSuchElementException,
            StaleElementReferenceException,
            TimeoutException,
            ElementNotInteractableException,
            ElementClickInterceptedException,
        )
        self.PATH = join(dirname(dirname(dirname(realpath(__file__)))),'dependency','chromedriver')
        self.user, self.password, self.URL = get_bank_authentication(self.bank).values()
        self.downloadFolder = r'C:\Users\hiepdang\Downloads'

    def __repr__(self):
        return '<BaseObjectOfBank>'

    def __GetCaptchaFromMail__(self,captcha_element):

        """
        This function get CAPTCHA image and send it to mail for user input

        :param captcha_element: Selenium's Web Driver of CAPTCHA image
        """

        if self.bank == 'IVB':
            regexPattern = '^[0-9a-z]{5}$'
        elif self.bank == 'BIDV':
            regexPattern = '^[0-9A-Za-z]{6}$'
        elif self.bank == 'VCB':
            regexPattern = '^[0-9A-Z]{6}$'
        else:
            raise ValueError('Invalid Bank Name')

        # Lấy CAPTCHA từ IB
        imgPATH = join(dirname(__file__),'CAPTCHA',f'{self.bank}.png')
        captcha_element.screenshot(imgPATH)
        # Decode image sang UTF-8
        base64Img = base64.b64encode(open(imgPATH,'rb').read()).decode('utf-8')
        # Gửi CAPTCHA qua bank
        outlook = Dispatch('outlook.application')
        mail = outlook.CreateItem(0)
        mail.To = 'hiepdang@phs.vn; duynguyen@phs.vn'
        mail.Subject = f"CAPTCHA Required: {self.bank}"
        mail.attachments.Add(imgPATH)
        html = f"""
        <html>
            <head></head>
            <body>
                <img alt="" src="data:image/png;base64,{base64Img}"/><br>
                <p style="font-family:Times New Roman; font-size:100%"><i>
                    Machine can't read CAPTCHA <br>
                    Reply this email with exact result to make the application continue
                </i></p>
                <p style="font-family:Times New Roman; font-size:90%"><i>
                    -- Generated by Reporting System
                </i></p>
            </body>
        </html>
        """
        mail.HTMLBody = html
        mail.Send()
        # Chờ phản hồi để nhận CAPTCHA
        mapi = Dispatch('outlook.application').GetNamespace("MAPI")
        now = dt.datetime.now()
        while True:
            for subFolder in ['DataAnalytics','HiepDang']: # Tùy vào người gửi là ai sẽ phân vào sub-folder mail khác nhau
                inbox = mapi.Folders.Item(1).Folders['Inbox'].Folders[subFolder]
                messages = inbox.Items
                messages = messages.Restrict(f"[Subject] = 'CAPTCHA Required: {self.bank}'")
                messages = messages.Restrict(f"[ReceivedTime] >= '" + now.strftime('%Y-%m-%d %H:%M %p') + "'")
                messages.Sort("[ReceivedTime]",Descending=True) # to ensure to read newest to oldest
                for message in messages:
                    subBody = message.Body.split()[0]
                    regex = re.compile(regexPattern)
                    match = regex.search(subBody)
                    if match:
                        message.Delete()
                        return match.group()

            time.sleep(5)  # 5s quét 1 lần


# có CAPTCHA
class BIDV(Base):

    def __init__(self,fromDate,toDate):
        
        """
        :param fromDate: Ngày bắt đầu lấy dữ liệu
        :param toDate: Ngầy kết thúc lấy dữ liệu
        """
        
        super().__init__('BIDV')
        self.fromDate = dt.datetime(fromDate.year,fromDate.month,fromDate.day)
        self.toDate = dt.datetime(toDate.year,toDate.month,toDate.day)
        self.driver, self.wait = self.__Login__()

    def __repr__(self):
        return f'<BankObject_BIDV>'

    def __Login__(self):

        driver = webdriver.Chrome(executable_path=self.PATH)
        driver.maximize_window()
        driver.get(self.URL)
        wait = WebDriverWait(driver,30,ignored_exceptions=self.ignored_exceptions)

        def GO(CAPTCHA):
            """
            Procedure login với CAPTCHA cho trước
            """
            # Input CAPTCHA
            captchaInput = driver.find_element(By.ID,'captcha')
            captchaInput.clear()
            captchaInput.send_keys(CAPTCHA)
            # Input Username
            userInput = driver.find_element(By.ID,'username')
            userInput.clear()
            userInput.send_keys(self.user)
            # Input Password
            userInput = driver.find_element(By.ID,'password')
            userInput.clear()
            userInput.send_keys(self.password)
            # Click "Đăng nhập"
            loginButton = driver.find_element(By.ID,'btLogin')
            loginButton.click()

        # CAPTCHA
        while True:
            captchaElement = wait.until(EC.presence_of_element_located((By.ID,'idImageCap')))
            imgPATH = join(dirname(__file__),'CAPTCHA',f'{self.bank}.png')
            captchaElement.screenshot(imgPATH) # download CAPTCHA về dưới dạng .png
            predictedCAPTCHA = pytesseract.image_to_string(imgPATH).replace('\n','').replace(' ','')
            print(predictedCAPTCHA)
            condition1 = len(predictedCAPTCHA) == 6
            condition2 = not re.findall('[^a-zA-Z0-9]',predictedCAPTCHA)
            condition3 = not re.findall('[ACGJTZWSIacgijqzws145789]',predictedCAPTCHA)
            if condition1 and condition2 and condition3: # Cases do not need refresh
                break
            driver.find_element(By.CLASS_NAME,'btnRefresh').click() # Cases need refresh
            time.sleep(0.5)

        GO(predictedCAPTCHA)

        # Check xem CAPTCHA đúng chưa, nếu chưa đúng -> gửi mail đọc CAPTCHA bằng tay
        errorMessages = driver.find_elements(By.CLASS_NAME,'errorMessage')
        if errorMessages:  # Nếu chưa đúng
            captchaElement = wait.until(EC.presence_of_element_located((By.ID,'idImageCap')))
            manualCAPTCHA = self.__GetCaptchaFromMail__(captchaElement)
            GO(manualCAPTCHA)

        return driver, wait


    def TienGuiThanhToan(self):

        # Click Menu bar
        self.wait.until(EC.presence_of_element_located((By.ID,'menu-toggle-22'))).click()
        # Click "Tài khoản"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Vấn tin'))).click()
        # Click "Tiền gửi thanh toán"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Tiền gửi thanh toán'))).click()
        # Lấy số lượng tài khoản
        Accounts = self.wait.until(EC.presence_of_all_elements_located((By.CLASS_NAME,'change')))
        accountNumber = len(Accounts)
        # Click vào tài khoản đầu tiên
        xpath = f'//*[@class="change"]'
        Account = self.wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        Account.click()
        # Click "Lịch sử giao dịch"
        xpath = f'//*[@data-action="btDetailTransaction"]'
        Button = self.wait.until(EC.visibility_of_element_located((By.XPATH,xpath)))
        Button.click()
        # Chọn tab "Thời gian"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Thời gian'))).click()
        # Lấy dữ liệu từng tài khoản
        records = []
        for d in pd.date_range(self.fromDate,self.toDate):
            # Từ ngày
            fromDateInput = self.wait.until(EC.presence_of_element_located((By.ID,'fromDate')))
            fromDateInput.clear()
            fromDateInput.send_keys((d-dt.timedelta(days=1)).strftime('%d/%m/%Y'))
            # Đến ngày
            toDateInput = self.wait.until(EC.presence_of_element_located((By.ID,'toDate')))
            toDateInput.clear()
            toDateInput.send_keys(d.strftime('%d/%m/%Y'))
            # Chọn từng tài khoản
            xpath = '//*[@aria-owns="accountNo_listbox"]'
            accountInput = self.wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
            accountInput.clear()
            i = 0
            while True:
                # Bấm mũi tên xuống để lấy từng TK (làm cách này để tránh lỗi)
                accountInput.send_keys(Keys.DOWN)
                value = accountInput.get_attribute('value')
                print(value)
                account = re.search('[0-9]{14}',value).group()
                time.sleep(0.5) # chờ load dữ liệu
                # Đóng pop up nếu có
                xpath = '//*[@data-bb-handler="ok"]'
                popupButtons = self.driver.find_elements(By.XPATH,xpath)
                if popupButtons:
                    popupButtons[0].click()
                # Lấy số dư
                balanceString = self.wait.until(EC.presence_of_element_located((By.ID,'lbSoDuCuoiKy'))).text
                balance = float(balanceString.replace(',',''))
                records.append((d,'BIDV',account,balance,'VND'))
                i += 1
                if i == accountNumber:
                    break

        self.driver.quit()
        balanceTable = pd.DataFrame(
            data=records,
            columns=['Date','Bank','AccountNumber','Balance','Currency']
        )

        return balanceTable


    def TienGuiKyHan(self):

        # Click Menu bar
        self.wait.until(EC.presence_of_element_located((By.ID,'menu-toggle-22'))).click()
        # Click "Tài khoản"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Vấn tin'))).click()
        # Click "Tiền gửi thanh toán"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Tiền gửi có kỳ hạn'))).click()

        # Lấy số lượng tài khoản
        Accounts = self.wait.until(EC.presence_of_all_elements_located((By.CLASS_NAME,'change')))
        accountNumber = len(Accounts)
        # Click vào tài khoản đầu tiên
        xpath = f'//*[@class="change"]'
        Account = self.wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        Account.click()
        # Click "Lịch sử giao dịch"
        xpath = f'//*[@data-action="btDetailTransaction"]'
        Button = self.wait.until(EC.visibility_of_element_located((By.XPATH,xpath)))
        Button.click()
        # Chọn tab "Thời gian"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Thời gian'))).click()
        # Lấy dữ liệu từng tài khoản
        records = []

# không CAPTCHA
class VTB(Base):

    def __init__(self,fromDate,toDate):

        """
        :param fromDate: Ngày bắt đầu lấy dữ liệu
        :param toDate: Ngầy kết thúc lấy dữ liệu
        """

        super().__init__('VTB')
        self.fromDate = dt.datetime(fromDate.year,fromDate.month,fromDate.day)
        self.toDate = dt.datetime(toDate.year,toDate.month,toDate.day)
        self.driver, self.wait = self.__Login__()

    def __repr__(self):
        return f'<BankObject_VTB>'

    def __Login__(self):

        driver = webdriver.Chrome(executable_path=self.PATH)
        driver.maximize_window()
        driver.get(self.URL)
        wait = WebDriverWait(driver,30,ignored_exceptions=self.ignored_exceptions)

        # Username
        userInput = wait.until(EC.presence_of_element_located((By.XPATH,'//*[@placeholder="Tên đăng nhập"]')))
        userInput.clear()
        userInput.send_keys(self.user)
        # Password
        passwordInput = wait.until(EC.presence_of_element_located((By.XPATH,'//*[@placeholder="Mật khẩu"]')))
        passwordInput.clear()
        passwordInput.send_keys(self.password)
        # Click đăng nhập
        loginButton = wait.until(EC.presence_of_element_located((By.XPATH,'//*[@type="submit"]')))
        loginButton.click()
        time.sleep(1)

        return driver, wait

    def TienGuiThanhToan(self):

        # Click menu "Tài khoản"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Tài khoản'))).click()
        # Click sub-menu "Danh sách tài khoản"
        self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Danh sách tài khoản'))).click()
        # table Element
        tableElement = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME,'MuiTableBody-root')))
        tableElement.find_element(By.LINK_TEXT,'Xem thêm').click()

        # Create function to clear input box and send dates as string
        def sendDate(element,d):
            action = ActionChains(self.driver)
            action.click(element)
            action.key_down(Keys.CONTROL,element)
            action.send_keys_to_element(element,'a')
            action.key_up(Keys.CONTROL,element)
            action.send_keys_to_element(element,Keys.BACKSPACE)
            action.send_keys_to_element(element,d.strftime('%d/%m/%Y'))
            action.send_keys_to_element(element,Keys.ENTER)
            action.perform()

        records = []
        accountNumbers = filter(lambda x: len(x)==12,tableElement.text.split('\n'))
        for x in accountNumbers:
            self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,x))).click()
            fromDateInput,toDateInput = self.wait.until(EC.visibility_of_all_elements_located((By.CLASS_NAME,'ant-picker-input')))
            for d in pd.date_range(self.fromDate,self.toDate):
                # Điền ngày
                sendDate(fromDateInput,d-dt.timedelta(days=15))
                sendDate(toDateInput,d)
                while True:
                    try:
                        self.driver.find_element(By.CLASS_NAME,'btn-submit').click()
                        break
                    except (Exception,):
                        pass
                # Lấy số dư
                rawResult = self.wait.until(EC.presence_of_all_elements_located((By.XPATH,'//*[@class="f-price"]/p/b')))[1].text
                closingBalance,currency = rawResult.split()
                records.append((d,'VTB',x,float(closingBalance.replace(',','')),currency))

            self.driver.back()
            self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,'Xem thêm'))).click()

        self.driver.quit()
        balanceTable = pd.DataFrame(
            data = records,
            columns=['Date','Bank','AccountNumber','Balance','Currency']
        )

        return balanceTable

# có CAPTCHA
class IVB(Base):

    def __init__(self,fromDate,toDate):

        """
        :param fromDate: Ngày bắt đầu lấy dữ liệu
        :param toDate: Ngầy kết thúc lấy dữ liệu
        """

        super().__init__('IVB')
        self.fromDate = dt.datetime(fromDate.year,fromDate.month,fromDate.day)
        self.toDate = dt.datetime(toDate.year,toDate.month,toDate.day)
        self.driver, self.wait = self.__Login__()

    def __repr__(self):
        return f'<BankObject_IVB>'

    def __Login__(self):

        driver = webdriver.Chrome(executable_path=self.PATH)
        driver.maximize_window()
        driver.get(self.URL)
        wait = WebDriverWait(driver,30,ignored_exceptions=self.ignored_exceptions)

        # Username
        xpath = '//*[@placeholder="Tên truy cập"]'
        userInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        userInput.clear()
        userInput.send_keys(self.user)
        # Password
        xpath = '//*[@placeholder="Mật khẩu"]'
        passwordInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        passwordInput.clear()
        passwordInput.send_keys(self.password)
        # CAPTCHA
        captcha_element = wait.until(EC.presence_of_element_located((By.ID,'safecode')))
        CAPTCHA = self.__GetCaptchaFromMail__(captcha_element)
        xpath = '//*[@placeholder="Mã xác thực"]'
        captchaInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        captchaInput.clear()
        captchaInput.send_keys(CAPTCHA)
        # Click Đăng nhập
        wait.until(EC.presence_of_element_located((By.XPATH,'//*[@onclick="logon()"]'))).click()
        # Nếu xuất hiện màn hình xác nhận
        xpath = '//*[@onclick="forceSubmit()"]'
        possibleButtons = driver.find_elements(By.XPATH,xpath)
        if possibleButtons:
            possibleButtons[0].click()

        return driver, wait

    def TienGuiThanhToan(self):

        # Click tab "Tài khoản"
        xpath = '//*[@data-menu-id="1"]'
        self.wait.until(EC.presence_of_element_located((By.XPATH,xpath))).click()
        # Click subtab "Sao kê tài khoản"
        self.wait.until(EC.visibility_of_element_located((By.ID,'2_2'))).click()
        # Chọn "Tài khoản thanh toán" từ dropdown list
        self.driver.switch_to.frame('mainframe')
        accountTypeInput = Select(self.wait.until(EC.presence_of_element_located((By.ID,'selectedAccType'))))
        accountTypeInput.select_by_visible_text('Tài khoản Thanh toán')

        # Điền số tài khoản:
        accountElems = self.driver.find_elements(By.XPATH,'//*[@id="account_list"]/option')
        options = [a.text for a in accountElems]
        records = []
        for option in options:
            time.sleep(1)
            account = option.split()[0]
            currency = option.split()[-1].replace(']','')
            if account not in ('1017816-066','1017816-069','1017816-068'):
                continue
            accountInput = Select(self.wait.until(EC.presence_of_element_located((By.ID,'account_list'))))
            accountInput.select_by_visible_text(option)

            # Điền ngày
            for d in pd.date_range(self.fromDate,self.toDate):
                # Từ ngày
                fromDateInput = self.driver.find_element(By.ID,'beginDate')
                fromDateInput.clear()
                fromDateInput.send_keys((d-dt.timedelta(days=15)).strftime('%d/%m/%Y'))
                # Đến ngày
                toDateInput = self.driver.find_element(By.ID,'endDate')
                toDateInput.clear()
                toDateInput.send_keys(d.strftime('%d/%m/%Y'))
                # Click "Truy vấn"
                self.driver.find_element(By.ID,'btnQuery').click()
                # Lấy số dư (cuối kỳ)
                valueStrings = [e.text for e in self.driver.find_elements(By.XPATH,'//*[@class="result_head"]')]
                balanceString = first(valueStrings, lambda x: 'Số dư cuối kỳ' in x)
                try:
                    balance = float(balanceString.split()[-1].replace(',',''))
                except (ValueError,): # catch lỗi web không hiện số khi ko có dữ liệu
                    balance = 0
                records.append((d,'IVB',account,balance,currency))

        self.driver.quit()
        balanceTable = pd.DataFrame(
            records,
            columns=['Date','Bank','AccountNumber','Balance','Currency']
        )

        return balanceTable

# có CAPTCHA
class VCB(Base):

    def __init__(self,fromDate,toDate):

        """
        :param fromDate: Ngày bắt đầu lấy dữ liệu
        :param toDate: Ngầy kết thúc lấy dữ liệu
        """

        super().__init__('VCB')
        self.fromDate = dt.datetime(fromDate.year,fromDate.month,fromDate.day)
        self.toDate = dt.datetime(toDate.year,toDate.month,toDate.day)
        self.driver, self.wait = self.__Login__()

    def __repr__(self):
        return f'<BankObject_VCB>'

    def __Login__(self):

        driver = webdriver.Chrome(executable_path=self.PATH)
        driver.maximize_window()
        driver.get(self.URL)
        wait = WebDriverWait(driver,30,ignored_exceptions=self.ignored_exceptions)

        def GO(CAPTCHA):
            """
            Procedure login với CAPTCHA cho trước
            """
            # Nhập CAPTCHA
            xpath = '//*[@placeholder="Nhập số bên"]'
            captchaInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
            captchaInput.clear()
            captchaInput.send_keys(CAPTCHA)
            # Username
            xpath = '//*[@placeholder="Tên truy cập"]'
            userInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
            userInput.clear()
            userInput.send_keys(self.user)
            # Password
            xpath = '//*[@placeholder="Mật khẩu"]'
            passwordInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
            passwordInput.clear()
            passwordInput.send_keys(self.password)
            # Click 'Đăng nhập'
            xpath = '//*[@value="Đăng nhập"]'
            wait.until(EC.presence_of_element_located((By.XPATH,xpath))).click()

        # CAPTCHA
        while True:
            xpath = '//*[@alt="Chuỗi bảo mật"]'
            CAPTCHA = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
            imgPATH = join(dirname(__file__),'CAPTCHA',f'{self.bank}.png')
            CAPTCHA.screenshot(imgPATH)  # download CAPTCHA về dưới dạng .png
            predictedCAPTCHA = pytesseract.image_to_string(imgPATH).replace('\n','')
            print(predictedCAPTCHA)
            condition1 = len(predictedCAPTCHA) == 6
            condition2 = not re.findall('[^0-9A-Z]',predictedCAPTCHA)
            condition3 = not re.findall('[048AGIOZRS]',predictedCAPTCHA)
            if condition1 and condition2 and condition3: # case không cần refresh
                break
            driver.refresh() # case cần refresh

        GO(predictedCAPTCHA)

        # Check xem CAPTCHA đúng chưa, nếu chưa đúng -> gửi mail đọc CAPTCHA bằng tay
        errorMessages = driver.find_elements(By.ID,'ctl00_Content_Login_CaptchaValidator')
        if errorMessages: # Nếu chưa đúng
            xpath = '//*[@alt="Chuỗi bảo mật"]'
            captchaElement = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
            imgPATH = join(dirname(__file__),'CAPTCHA',f'{self.bank}.png')
            captchaElement.screenshot(imgPATH)  # download CAPTCHA về dưới dạng .png
            manualCAPTCHA = self.__GetCaptchaFromMail__(captchaElement)
            GO(manualCAPTCHA)

        return driver, wait

    def TienGuiThanhToan(self):

        # Lấy danh sách đường dẫn vào tài khoản thanh toán
        xpath = '//*[@id="dstkdd-tbody"]//td/a'
        accountElems = self.wait.until(EC.presence_of_all_elements_located((By.XPATH,xpath)))
        URLs = [e.get_attribute('href') for e in accountElems]

        # Create function to clear input box and send dates as string
        def sendDate(element,d):
            action = ActionChains(self.driver)
            action.click(element)
            time.sleep(0.5)
            action.key_down(Keys.CONTROL,element)
            action.send_keys_to_element(element,'a')
            action.key_up(Keys.CONTROL,element)
            action.send_keys_to_element(element,Keys.BACKSPACE)
            action.send_keys_to_element(element,d.strftime('%d/%m/%Y'))
            action.send_keys_to_element(element,Keys.ENTER)
            action.perform()

        records = []
        for URL in URLs:
            self.driver.get(URL)
            time.sleep(1) # chờ để hiện số tài khoản (bắt buộc)
            account = self.wait.until(EC.presence_of_element_located((By.ID,'Lbl_STK_Title'))).text
            currency = self.wait.until(EC.visibility_of_element_located((By.ID,'Lbl_SDKD'))).text.split()[-1]
            for d in pd.date_range(self.fromDate,self.toDate):
                # Điền ngày
                startDateInput = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME,'startDate')))
                self.driver.execute_script(f'window.scrollTo(0,500)')
                sendDate(startDateInput,d-dt.timedelta(days=15)) # VCB rất dễ lỗi ko hiện dữ liệu khi startDate = endDate
                endDateInput = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME,'endDate')))
                sendDate(endDateInput,d)
                # Click "Xem sao kê"
                self.wait.until(EC.presence_of_element_located((By.ID,'TransByDate'))).click()
                time.sleep(1) # chờ load xong để tránh rủi ro đang hiện số cũ
                # Số dư cuối kỳ
                ID = 'ctl00_Content_TransactionDetail_EndBalance'
                balanceString = self.wait.until(EC.visibility_of_element_located((By.ID,ID))).text
                balance = float(balanceString.replace(',',''))
                records.append((d,'VCB',account,balance,currency))

        self.driver.quit()
        balanceTable = pd.DataFrame(
            records,
            columns=['Date','Bank','AccountNumber','Balance','Currency']
        )

        return balanceTable

# không CAPTCHA
class EIB(Base):

    def __init__(self,fromDate,toDate):

        """
        :param fromDate: Ngày bắt đầu lấy dữ liệu
        :param toDate: Ngầy kết thúc lấy dữ liệu
        """

        super().__init__('EIB')
        self.fromDate = dt.datetime(fromDate.year,fromDate.month,fromDate.day)
        self.toDate = dt.datetime(toDate.year,toDate.month,toDate.day)
        self.driver, self.wait = self.__Login__()

    def __repr__(self):
        return f'<BankObject_EIB>'

    def __Login__(self):

        driver = webdriver.Chrome(executable_path=self.PATH)
        driver.maximize_window()
        driver.get(self.URL)
        wait = WebDriverWait(driver,30,ignored_exceptions=self.ignored_exceptions)

        # Tên đâng nhập
        xpath = '//*[@placeholder="Tên đăng nhập"]'
        userInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        userInput.clear()
        userInput.send_keys(self.user)
        # Mật khẩu
        xpath = '//*[@placeholder="Mật khẩu"]'
        passwordInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        passwordInput.clear()
        passwordInput.send_keys(self.password)
        # Click "Đăng nhập"
        wait.until(EC.presence_of_element_located((By.CLASS_NAME,'btn-primary'))).click()

        return driver, wait

    def TienGuiThanhToan(self):

        # Click Menu Tài khoản --> Tiền gửi thanh toán
        action = ActionChains(self.driver)
        xpath = '//*[@class="navigation-menu"]/li[2]/a'
        menuAccount = self.wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        action.move_to_element(menuAccount)
        xpath = '//*[@href="/KHDN/corp/account/payment"]'
        currentAccount = self.wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        action.click(currentAccount)
        action.perform()
        # Lấy danh sách tài khoản
        xpath = '//tbody/tr/th/a'
        accountElems = self.wait.until(EC.presence_of_all_elements_located((By.XPATH,xpath)))
        accounts = [e.text for e in accountElems]
        # Lấy số dư tài khoản
        records = []
        for account in accounts:
            Account = self.wait.until(EC.presence_of_element_located((By.LINK_TEXT,account)))
            Account.click()
            # Click Xem lịch sử tài khoản
            xpath = '//*[@class="modal-footer"]/button'
            self.wait.until(EC.presence_of_element_located((By.XPATH,xpath))).click() # nút đầu tiên
            for d in pd.date_range(self.fromDate,self.toDate):
                xpath = '//*[@placeholder="dd/mm/yyyy"]'
                fromDateInput,toDateInput = self.wait.until(EC.presence_of_all_elements_located((By.XPATH,xpath)))
                # Từ ngày
                fromDateInput.clear()
                fromDateInput.send_keys((d-dt.timedelta(days=15)).strftime('%d/%m/%Y'))
                # Đến ngày
                toDateInput.clear()
                toDateInput.send_keys(d.strftime('%d/%m/%Y'))
                # Click "Tìm kiếm"
                _, searchButton = self.wait.until(EC.presence_of_all_elements_located((By.CLASS_NAME,'btn-primary')))
                while True:
                    try:
                        searchButton.click()
                        time.sleep(0.5)
                        break
                    except (ElementClickInterceptedException,):
                        pass
                # Lấy số dư
                xpath = '//*[@class="form-control text-right ng-untouched ng-pristine"]'
                _, Balance = self.wait.until(EC.presence_of_all_elements_located((By.XPATH,xpath)))
                balanceString, currency = Balance.get_attribute('value').split()
                balance = float(balanceString.replace(',',''))
                if balance: # if balance != 0
                    records.append((d,'EIB',account,balance,currency))
                else:
                    records.append((d,'EIB',account,np.nan,currency))

            self.driver.back()

        self.driver.quit()
        balanceTable = pd.DataFrame(
            records,
            columns=['Date','Bank','AccountNumber','Balance','Currency']
        )
        # Xử lý lỗi EIB: Ngày nào ko có giao dịch thì số dư cuối kỳ = 0, bằng cách: forward fill
        for account in balanceTable['AccountNumber'].unique():
            mask = balanceTable['AccountNumber']==account
            balanceTable.loc[mask] = balanceTable.loc[mask].fillna(method='ffill')
        # Xử lý những thằng thật sự bằng 0
        balanceTable = balanceTable.fillna(0)

        return balanceTable

# không CAPTCHA
class OCB(Base):

    def __init__(self,fromDate,toDate):

        """
        :param fromDate: Ngày bắt đầu lấy dữ liệu
        :param toDate: Ngầy kết thúc lấy dữ liệu
        """

        super().__init__('OCB')
        self.fromDate = dt.datetime(fromDate.year,fromDate.month,fromDate.day)
        self.toDate = dt.datetime(toDate.year,toDate.month,toDate.day)
        self.driver, self.wait = self.__Login__()

    def __repr__(self):
        return f'<BankObject_OCB>'

    def __Login__(self):

        driver = webdriver.Chrome(executable_path=self.PATH)
        driver.maximize_window()
        driver.get(self.URL)
        wait = WebDriverWait(driver,30,ignored_exceptions=self.ignored_exceptions)

        # Trong trường hợp có pop-up window
        exitPopup = wait.until(EC.presence_of_element_located((By.CLASS_NAME,'x-button-popup-login')))
        if exitPopup.is_displayed():  # có pop-up window
            exitPopup.click()
        # Tên đâng nhập
        xpath = '//*[@placeholder="Tên đăng nhập"]'
        userInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        userInput.clear()
        userInput.send_keys(self.user)
        # Click "Tiếp tục"
        wait.until(EC.presence_of_element_located((By.ID,'loginSubmitButton'))).click()
        # Mật khẩu
        xpath = '//*[@placeholder="Mật khẩu"]'
        passwordInput = wait.until(EC.presence_of_element_located((By.XPATH,xpath)))
        passwordInput.clear()
        passwordInput.send_keys(self.password)
        # Click "Đăng nhập"
        wait.until(EC.presence_of_element_located((By.ID,'loginSubmitButton'))).click()

        return driver, wait

    def TienGuiThanhToan(self):

        # Click main menu
        self.wait.until(EC.presence_of_element_located((By.ID,'main-menu-icon'))).click()
        # Click Thông tin tài khoản --> Sao kê tài khoản
        xpath = '//*[@class="ahref"]/*[@class="accounts-icon"]'
        _, accountButton = self.wait.until(EC.presence_of_all_elements_located((By.XPATH,xpath)))
        accountButton.click()
        xpath = '//*[@id="side-nav"]/ul/li[2]/div[3]/span'
        self.wait.until(EC.presence_of_element_located((By.XPATH,xpath))).click()
        time.sleep(5) # chờ chuyển trang
        # Lấy danh sách tài khoản
        i = 0
        records = []
        while True:
            # Click dropdown button
            self.wait.until(EC.presence_of_element_located((By.CLASS_NAME,'indicator'))).click()  # dropdown button
            options = self.wait.until(EC.visibility_of_all_elements_located((By.CLASS_NAME,'rb-account-select__account-desc-row')))
            if i == len(options):
                break
            # Nhập số tài khoản
            Entry = options[i]; i += 1
            accountNumber = Entry.text.split('\n')[0].replace(' ','')
            Entry.click()
            # Click "Tìm kiếm nâng cao"
            xpath = '//*[@ng-click="toggleAdvancedSearch()"]'
            self.wait.until(EC.presence_of_element_located((By.XPATH,xpath))).click()
            # Tick chọn tính năng khoảng thời gian
            xpath = '//*[@class="bd-radio-option__marker"]'
            _, rangeButton = self.wait.until(EC.visibility_of_all_elements_located((By.XPATH,xpath)))
            rangeButton.click()
            for d in pd.date_range(self.fromDate,self.toDate):
                # Từ ngày
                fromDateInput = self.wait.until(EC.presence_of_element_located((By.NAME,'dateFromInput')))
                fromDateInput.clear()
                fromDateInput.send_keys((d-dt.timedelta(days=15)).strftime('%d.%m.%Y'))
                # Đến ngày
                toDateInput = self.wait.until(EC.presence_of_element_located((By.NAME,'dateToInput')))
                toDateInput.clear()
                toDateInput.send_keys(d.strftime('%d.%m.%Y'))
                # Lấy số dư cuối kỳ
                while True:
                    while True: # click đến khi được thì thôi
                        try:
                            searchButton = self.wait.until(EC.presence_of_element_located((By.XPATH,'//*[@bd-id="search_button_mobile"]')))
                            searchButton.click()
                            break
                        except (ElementClickInterceptedException,):
                            pass
                    time.sleep(1) # chờ load data
                    self.driver.execute_script(f'window.scrollTo(0,500)')
                    fullString = self.driver.find_elements(By.CLASS_NAME,'bd-amount')[-1].text
                    if fullString != '':
                        balanceString, currency = fullString.split()
                        balance = float(balanceString.replace(',',''))
                        records.append((d,'OCB',accountNumber,balance,currency))
                        # Scroll lên đầu trang
                        self.driver.execute_script(f'window.scrollTo(0,0)')
                        break
                    # Scroll lên đầu trang
                    self.driver.execute_script(f'window.scrollTo(0,0)')
                    time.sleep(1) # tránh click khi chưa scroll xong

            # Click "Ẩn tìm kiếm nâng cao"
            xpath = '//*[@ng-click="toggleAdvancedSearch()"]'
            self.wait.until(EC.presence_of_element_located((By.XPATH,xpath))).click()

        self.driver.quit()
        balanceTable  = pd.DataFrame(
            records,
            columns=['Date','Bank','AccountNumber','Balance','Currency'],
        )

        return balanceTable

